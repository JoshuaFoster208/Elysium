<head>
    <title>Elysium</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="description" content="Homepage of the Elysium Project" />
    <meta name="theme-color" content="#000000">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="css/extracted-styles.css">
    <link href="https://fonts.googleapis.com/css?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="js/extracted-helpers.js"></script>
</head>
	
<div id="main-info">

    Welcome to the Elysium Project.
    <br><br><br><br>
    <a href="register.html">Register Now</a>

</div>

<body style="cursor: default;">
    

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-118553867-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-118553867-1');
</script>
<script>

    var out = loadFile("shaders/0.shader");
</script>
<link rel="stylesheet" href="css/codemirror.css">
<link rel="stylesheet" href="css/default.css">
<script src="js/lzma.js"></script>
<script src="js/jquery.js"></script>
<script src="js/helpers.js"></script>
<script src="js/codemirror.js"></script>
<script src="js/glsl.js"></script>



<!-- SHADER INJECTION GOES HERE -->
<script id="example" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision highp float; 
    #endif

    vec2 uv;

    uniform float time;
    uniform vec2 resolution;

    const vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)
    const vec2 ch_space = ch_size + vec2(1.0, 1.0);    // character distance Vector(X,Y)
    const vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position
          vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)
    //      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)
    //const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)

    #define REPEAT_SIGN false // True/False; True=Multiple, False=Single

    /* 16 segment display...Akin to LED Display.

    Segment bit positions: 


     binary to hex -> 0x119F
    */

    #define n0 ddigit(0x22FF);
    #define n1 ddigit(0x0281);
    #define n2 ddigit(0x1177);
    #define n3 ddigit(0x11E7);
    #define n4 ddigit(0x5508);
    #define n5 ddigit(0x11EE);
    #define n6 ddigit(0x11FE);
    #define n7 ddigit(0x2206);
    #define n8 ddigit(0x11FF);
    #define n9 ddigit(0x11EF);

    #define A ddigit(0x119F);
    #define B ddigit(0x927E);
    #define C ddigit(0x007E);
    #define D ddigit(0x44E7);
    #define E ddigit(0x107E);
    #define F ddigit(0x101E);
    #define G ddigit(0x807E);
    #define H ddigit(0x1199);
    #define I ddigit(0x4466);
    #define J ddigit(0x4436);
    #define K ddigit(0x9218);
    #define L ddigit(0x0078);
    #define M ddigit(0x0A99);
    #define N ddigit(0x8899);
    #define O ddigit(0x00FF);
    #define P ddigit(0x111F);
    #define Q ddigit(0x80FF);
    #define R ddigit(0x911F);
    #define S ddigit(0x8866);
    #define T ddigit(0x4406);
    #define U ddigit(0x00F9);
    #define V ddigit(0x2218);
    #define W ddigit(0xA099);
    #define X ddigit(0xAA00);
    #define Y ddigit(0x4A00);
    #define Z ddigit(0x2266);
    #define _ ch_pos.x += ch_space.x;
    #define s_dot     ddigit(0);
    #define s_minus   ddigit(0x1100);
    #define s_plus    ddigit(0x5500);
    #define s_greater ddigit(0x2800);
    #define s_less    ddigit(0x8200);
    #define s_sqrt    ddigit(0x0C02);
    #define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0; ch_pos.x-= 0.5;
    #define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;
    #define nl3 ch_pos = ch_start;	ch_pos.y -= 9.0;

    float dseg(vec2 p0, vec2 p1)
    {
        vec2 dir = normalize(p1 - p0);
        vec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);
        return distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));   
    }

    bool bit(int n, int b)
    {
        return mod(floor(float(n) / exp2(floor(float(b)))), 2.0) != 0.0;
    }

    float d = 1e6;

    void ddigit(int n)
    {
        float v = 1e6;	
        vec2 cp = uv - ch_pos;
        if (n == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));
        if (bit(n,  0)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));
        if (bit(n,  1)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000000000)));
        if (bit(n,  2)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));
        if (bit(n,  3)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));
        if (bit(n,  4)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));
        if (bit(n,  5)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));
        if (bit(n,  6)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));
        if (bit(n,  7)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));
        if (bit(n,  8)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));
        if (bit(n,  9)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));
        if (bit(n, 10)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));
        if (bit(n, 11)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));
        if (bit(n, 12)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));
        if (bit(n, 13)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));
        if (bit(n, 14)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));
        if (bit(n, 15)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));
        ch_pos.x += ch_space.x;
        d = min(d, v);
    }
    mat2 rotate(float a)
    {
        float c = cos(a);
        float s = sin(a);
        return mat2(c, s, -s, c);
    }
    vec3 hsv2rgb_smooth( in vec3 c )
    {
        vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );

        rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing	

        return c.z * mix( vec3(1.0), rgb, c.y);
    }
    void main( void ) 
    {
        
        vec2 aspect = resolution.xy / resolution.y;
        uv = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;
        float _d =  1.0-length(uv);
        uv *= 14.0 ;
        uv.y -= 1.;
        //uv *= rotate(time+uv.x*0.05);

        
        
        vec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv.y*0.1,0.5,1.0));

        //vec3 bg_color = vec3(_d*0.8*sin(time)*3.0, _d*0.0, _d*0.00);
        vec3 bg_color = vec3(0.1,_d*0.8*abs(sin(time))*0.7,0.1);
        
        

        
        uv.y += -1.+sin(time+uv.x*0.3)*0.5;
        ch_pos = ch_start;

                   X D M T K 
                 
        vec3 color = mix(ch_color, bg_color, 1.0- (0.04 / d*2.0));  // shading
        gl_FragColor = vec4(color, 1.0);
    }

    </script>
    <script>
    var shaderinjection = document.getElementById("example");
    shaderinjection.innerHTML = out;
    </script>    
            <script id="fragmentShader" type="x-shader/x-fragment">

                #ifdef GL_ES
                precision mediump float;
                #endif

                uniform vec2 resolution;
                uniform sampler2D texture;

                void main() {

                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    gl_FragColor = texture2D( texture, uv );

                }

            </script>

            <script id="vertexShader" type="x-shader/x-vertex">

                attribute vec3 position;

                void main() {

                    gl_Position = vec4( position, 1.0 );

                }

            </script>

            <script id="surfaceVertexShader" type="x-shader/x-vertex">

                attribute vec3 position;
                attribute vec2 surfacePosAttrib;
                varying vec2 surfacePosition;

                void main() {

                    surfacePosition = surfacePosAttrib;
                    gl_Position = vec4( position, 1.0 );

                }

            </script>

            <script>

                initialize_helper();

                var compressor=initialize_compressor();

                if ( !window.requestAnimationFrame ) {

                    window.requestAnimationFrame = ( function() {

                        return window.webkitRequestAnimationFrame ||
                            window.mozRequestAnimationFrame ||
                            window.oRequestAnimationFrame ||
                            window.msRequestAnimationFrame ||
                            function ( callback, element ) {

                                window.setTimeout( callback, 1000 / 60 );

                            };

                    } )();

                }

                // Get older browsers safely through init code, so users can read the
                // message about how to download newer browsers.
                if (!Date.now) {
                    Date.now = function() {
                        return +new Date();
                    };
                }

                // Greetings to Iq/RGBA! ;)

                var quality = 2, quality_levels = [ 0.5, 1, 2, 4, 8 ];
                var toolbar, compileButton, fullscreenButton, compileTimer, errorLines = [];
                var code, canvas, gl, buffer, currentProgram, vertexPosition, screenVertexPosition, panButton,
                parameters = { startTime: Date.now(), time: 0, mouseX: 0.5, mouseY: 0.5, screenWidth: 0, screenHeight: 0 },
                surface = { centerX: 0, centerY: 0, width: 1, height: 1, isPanning: false, isZooming: false, lastX: 0, lastY: 0 },
                frontTarget, backTarget, screenProgram, getWebGL, resizer = {}, compileOnChangeCode = true;

                init();
                if (gl) { animate(); }

                function init() {

                    if (!document.addEventListener) {
                        document.location = 'http://get.webgl.org/';
                        return;
                    }

                    canvas = document.createElement( 'canvas' );
                    canvas.style.display = 'block';
                    document.body.appendChild( canvas );

                    //


                    //

                    toolbar = document.createElement( 'div' );
                    toolbar.style.position = 'absolute';
                    toolbar.style.display = 'none';
                    toolbar.style.top = '25px';
                    toolbar.style.left = '25px';
                    document.body.appendChild( toolbar );

                    var rightside = document.createElement( 'div' );
                    rightside.style.cssFloat = 'right';
                    toolbar.appendChild( rightside );

                    panButton = document.createElement( 'button' );
                    panButton.textContent = 'pan/zoom';
                    panButton.style.cursor = 'move';
                    panButton.style.display = 'none';
                    panButton.title = "Pan: left-drag, Zoom: right-drag. Use 'hide code' for a large pan/zoom area.";
                    rightside.appendChild( panButton );

                    fullscreenButton = document.createElement( 'button' );
                    fullscreenButton.textContent = 'fullscreen';
                    fullscreenButton.title = 'Press F11 to enter or leave fullscreen mode';
                    fullscreenButton.addEventListener( 'click', function ( event ) {

                        if (document.body.requestFullScreen) {
                            document.body.requestFullScreen();
                        } else if (document.body.mozRequestFullScreen) {
                            document.body.mozRequestFullScreen();
                        } else if (document.body.webkitRequestFullScreen) {
                            document.body.webkitRequestFullScreen( Element.ALLOW_KEYBOARD_INPUT );
                        }

                    }, false );

                    rightside.appendChild( fullscreenButton );

                    var button = document.createElement( 'a' );
                    button.textContent = 'gallery';
                    button.href = '/';
                    rightside.appendChild( button );

                    var button = document.createElement( 'button' );
                    button.textContent = 'hide code';
                    button.addEventListener( 'click', function ( event ) {

                        if ( isCodeVisible() ) {

                            button.textContent = 'show code';
                            code.getWrapperElement().style.display = 'none';
                            compileButton.style.visibility = 'hidden';
                            set_save_button('hidden');
                            set_parent_button('hidden');
                            stopHideUI();

                        } else {

                            button.textContent = 'hide code';
                            code.getWrapperElement().style.display = '';
                            compileButton.style.visibility = 'visible';
                            set_save_button('visible');
                            set_parent_button('visible');

                        }

                    }, false );
                    toolbar.appendChild( button );

                    var select = document.createElement( 'select' );

                    for ( var i = 0; i < quality_levels.length; i ++ ) {

                        var option = document.createElement( 'option' );
                        option.textContent = quality_levels[ i ];
                        if ( quality_levels[ i ] == quality ) option.selected = true;
                        select.appendChild( option );

                    }

                    select.addEventListener( 'change', function ( event ) {

                        quality = quality_levels[ event.target.selectedIndex ];
                        onWindowResize();

                    }, false );

                    toolbar.appendChild( select );

                    compileButton = document.createElement( 'button' );
                    compileButton.textContent = 'compile';
                    compileButton.addEventListener( 'click', function ( event ) {

                        compile();

                    }, false );
                    toolbar.appendChild( compileButton );

                    // from helper.js
                    add_server_buttons();

                    // Initialise WebGL

                    try {

                        gl = canvas.getContext( 'experimental-webgl', { preserveDrawingBuffer: true } );

                    } catch( error ) { }

                    if ( !gl ) {

                        alert("WebGL not supported, but code will be shown.");

                    } else {
                        
                        // enable dFdx, dFdy, fwidth
                        gl.getExtension('OES_standard_derivatives');

                        // Create vertex buffer (2 triangles)

                        buffer = gl.createBuffer();
                        gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
                        gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( [ - 1.0, - 1.0, 1.0, - 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0 ] ), gl.STATIC_DRAW );

                        // Create surface buffer (coordinates at screen corners)

                        surface.buffer = gl.createBuffer();
                    }

                    // initialize code editor
                    code = CodeMirror(document.body, {
                        lineNumbers: true,
                        matchBrackets: true,
                        indentWithTabs: true,
                        tabSize: 8,
                        indentUnit: 8,
                        mode: "text/x-glsl",
                        onChange: function () {
                            if (compileOnChangeCode) {
                                clearTimeout(compileTimer);
                                compileTimer = setTimeout(compile, 500);
                            }
                        }
                    });
                    code.getWrapperElement().style.display = '';

                    resizer.offsetMouseX = 0;
                    resizer.offsetMouseY = 0;
                    resizer.isResizing = false;
                    resizer.currentWidth = 100;
                    resizer.currentHeight = 100;
                    resizer.minWidth = 100;
                    resizer.minHeight = 100;
                    resizer.maxWidth = 100;
                    resizer.maxHeight = 100;
                    resizer.element = document.createElement( 'div' );
                    resizer.element.className = 'resizer';
                    code.getWrapperElement().appendChild(resizer.element);

                    resizer.element.addEventListener( 'mousedown', function ( event ) {
                        if (event.button !== 2) {
                            resizer.offsetMouseX = event.clientX - resizer.currentWidth;
                            resizer.offsetMouseY = event.clientY - resizer.currentHeight;
                            resizer.isResizing = true;
                            event.preventDefault();
                        }
                    }, false );
                    
                    if (gl) {

                        var surfaceMouseDown = function ( event ) {

                            if (event.shiftKey) {
                                resetSurface();
                            }

                            if (event.button === 0) {
                                surface.isPanning = true;
                                document.body.style.cursor = 'move';
                            } else {
                                surface.isZooming = true;
                                document.body.style.cursor = 'se-resize';
                                panButton.style.cursor = 'se-resize';
                            }

                            surface.lastX = event.clientX;
                            surface.lastY = event.clientY;
                            event.preventDefault();

                        };

                        var noContextMenu = function ( event ) {

                            event.preventDefault();

                        };

                        canvas.addEventListener( 'mousedown', surfaceMouseDown, false );
                        panButton.addEventListener( 'mousedown', surfaceMouseDown, false );

                        canvas.addEventListener( 'contextmenu', noContextMenu, false);
                        panButton.addEventListener( 'contextmenu', noContextMenu, false);
                    }
                    
                    var clientXLast, clientYLast;

                    document.addEventListener( 'mousemove', function ( event ) {

                        var clientX = event.clientX;
                        var clientY = event.clientY;

                        if (clientXLast == clientX && clientYLast == clientY)
                            return;

                        clientXLast = clientX;
                        clientYLast = clientY;

                        stopHideUI();

                        var codeElement, dx, dy;
                        
                        parameters.mouseX = clientX / window.innerWidth;
                        parameters.mouseY = 1 - clientY / window.innerHeight;
                            
                        if (resizer.isResizing) {

                            resizer.currentWidth = Math.max(Math.min(clientX - resizer.offsetMouseX, resizer.maxWidth), resizer.minWidth);
                            resizer.currentHeight = Math.max(Math.min(clientY - resizer.offsetMouseY, resizer.maxHeight), resizer.minWidth);
                            codeElement = code.getWrapperElement();
                            codeElement.style.width = resizer.currentWidth + 'px';
                            codeElement.style.height = resizer.currentHeight + 'px';
                            code.refresh();
                            event.preventDefault();

                        } else if (surface.isPanning) {

                            dx = clientX - surface.lastX;
                            dy = clientY - surface.lastY;
                            surface.centerX -= dx * surface.width / window.innerWidth;
                            surface.centerY += dy * surface.height / window.innerHeight;
                            surface.lastX = clientX;
                            surface.lastY = clientY;
                            computeSurfaceCorners();
                            event.preventDefault();

                        } else if (surface.isZooming) {

                            dx = clientX - surface.lastX;
                            dy = clientY - surface.lastY;
                            surface.height *= Math.pow(0.997, dx + dy);
                            surface.lastX = clientX;
                            surface.lastY = clientY;
                            computeSurfaceCorners();
                            event.preventDefault();

                        }
                    }, false );

                    function settleDown ( event ) {
                        resizer.isResizing = surface.isPanning = surface.isZooming = false;
                        document.body.style.cursor = 'default';
                        panButton.style.cursor = 'move';
                    }

                    function mouseLeave(event) {
                        settleDown(event);

                        if (!isCodeVisible())
                            startHideUITimer();
                    }

                    document.addEventListener( 'mouseup', settleDown, false );
                    document.addEventListener( 'mouseleave', mouseLeave, false );

                    onWindowResize();
                    window.addEventListener( 'resize', onWindowResize, false );
                    load_url_code();

                    compileScreenProgram();

                }

                function isCodeVisible() {
                    return code && code.getWrapperElement().style.display !== 'none';
                }

                var hideUITimer;
                var isUIHidden = false;

                function startHideUITimer () {

                    stopHideUITimer();
                    if (!isUIHidden && !isCodeVisible())
                        hideUITimer = window.setTimeout(onHideUITimer, 1000 * 5 );

                    function onHideUITimer() {

                        stopHideUITimer();
                        if (!isUIHidden && !isCodeVisible()) {

                            isUIHidden = true;
                            toolbar.style.display = 'none';
                            document.body.style.cursor = 'none';
                        }
                    }

                    function stopHideUITimer () {

                        if (hideUITimer) {

                            window.clearTimeout(hideUITimer);
                            hideUITimer = 0;
                        }
                    }
                }

                function stopHideUI () {

                    if (isUIHidden) {

                        isUIHidden = false;
                        toolbar.style.display = '';
                        document.body.style.cursor = '';
                    }
                    startHideUITimer();
                }


                function computeSurfaceCorners() {

                    if (gl) {

                        surface.width = surface.height * parameters.screenWidth / parameters.screenHeight;
                        
                        var halfWidth = surface.width * 0.5, halfHeight = surface.height * 0.5;
                        
                        gl.bindBuffer( gl.ARRAY_BUFFER, surface.buffer );
                        gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( [
                            surface.centerX - halfWidth, surface.centerY - halfHeight,
                            surface.centerX + halfWidth, surface.centerY - halfHeight,
                            surface.centerX - halfWidth, surface.centerY + halfHeight,
                            surface.centerX + halfWidth, surface.centerY - halfHeight,
                            surface.centerX + halfWidth, surface.centerY + halfHeight,
                            surface.centerX - halfWidth, surface.centerY + halfHeight ] ), gl.STATIC_DRAW );

                    }

                }

                function resetSurface() {

                    surface.centerX = surface.centerY = 0;
                    surface.height = 1;
                    computeSurfaceCorners();

                }

                function compile() {
                
                    if (!gl) {
                    
                        if (!getWebGL) {
                        
                            getWebGL = true;
                            compileButton.addEventListener( 'click', function ( event ) {

                                document.location = 'http://get.webgl.org/';

                            }, false );
                            compileButton.title = 'http://get.webgl.org/';
                            compileButton.style.color = '#ff0000';
                            compileButton.textContent = 'WebGL not supported!';
                            set_save_button('hidden');
                            
                        }
                        return;
                        
                    }

                    var program = gl.createProgram();
                    var fragment = code.getValue();
                    var vertex = document.getElementById( 'surfaceVertexShader' ).textContent;

                    var vs = createShader( vertex, gl.VERTEX_SHADER );
                    var fs = createShader( fragment, gl.FRAGMENT_SHADER );

                    if ( vs == null || fs == null ) return null;

                    gl.attachShader( program, vs );
                    gl.attachShader( program, fs );

                    gl.deleteShader( vs );
                    gl.deleteShader( fs );

                    gl.linkProgram( program );

                    if ( !gl.getProgramParameter( program, gl.LINK_STATUS ) ) {

                        var error = gl.getProgramInfoLog( program );

                        compileButton.title = error;
                        console.error( error );

                        console.error( 'VALIDATE_STATUS: ' + gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'ERROR: ' + gl.getError() );
                        compileButton.style.color = '#ff0000';
                        compileButton.textContent = 'compiled with errors';

                        set_save_button('hidden');

                        return;

                    }

                    if ( currentProgram ) {

                        gl.deleteProgram( currentProgram );
                        setURL( fragment );

                    }

                    currentProgram = program;

                    compileButton.style.color = '#00ff00';
                    compileButton.textContent = 'compiled successfully';

                    set_save_button('visible');

                    panButton.style.display = (fragment.indexOf('varying vec2 surfacePosition;') >= 0) ? 'inline' : 'none';

                    // Cache uniforms

                    cacheUniformLocation( program, 'time' );
                    cacheUniformLocation( program, 'mouse' );
                    cacheUniformLocation( program, 'resolution' );
                    cacheUniformLocation( program, 'backbuffer' );
                    cacheUniformLocation( program, 'surfaceSize' );

                    // Load program into GPU

                    gl.useProgram( currentProgram );

                    // Set up buffers

                    surface.positionAttribute = gl.getAttribLocation(currentProgram, "surfacePosAttrib");
                    gl.enableVertexAttribArray(surface.positionAttribute);

                    vertexPosition = gl.getAttribLocation(currentProgram, "position");
                    gl.enableVertexAttribArray( vertexPosition );

                }

                function compileScreenProgram() {
                
                    if (!gl) { return; }

                    var program = gl.createProgram();
                    var fragment = document.getElementById( 'fragmentShader' ).textContent;
                    var vertex = document.getElementById( 'vertexShader' ).textContent;

                    var vs = createShader( vertex, gl.VERTEX_SHADER );
                    var fs = createShader( fragment, gl.FRAGMENT_SHADER );

                    gl.attachShader( program, vs );
                    gl.attachShader( program, fs );

                    gl.deleteShader( vs );
                    gl.deleteShader( fs );

                    gl.linkProgram( program );

                    if ( !gl.getProgramParameter( program, gl.LINK_STATUS ) ) {

                        console.error( 'VALIDATE_STATUS: ' + gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'ERROR: ' + gl.getError() );

                        return;

                    }

                    screenProgram = program;

                    gl.useProgram( screenProgram );

                    cacheUniformLocation( program, 'resolution' );
                    cacheUniformLocation( program, 'texture' );

                    screenVertexPosition = gl.getAttribLocation(screenProgram, "position");
                    gl.enableVertexAttribArray( screenVertexPosition );

                }

                function cacheUniformLocation( program, label ) {

                    if ( program.uniformsCache === undefined ) {

                        program.uniformsCache = {};

                    }

                    program.uniformsCache[ label ] = gl.getUniformLocation( program, label );

                }

                //

                function createTarget( width, height ) {

                    var target = {};

                    target.framebuffer = gl.createFramebuffer();
                    target.renderbuffer = gl.createRenderbuffer();
                    target.texture = gl.createTexture();

                    // set up framebuffer

                    gl.bindTexture( gl.TEXTURE_2D, target.texture );
                    gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );

                    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
                    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );

                    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
                    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

                    gl.bindFramebuffer( gl.FRAMEBUFFER, target.framebuffer );
                    gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0 );

                    // set up renderbuffer

                    gl.bindRenderbuffer( gl.RENDERBUFFER, target.renderbuffer );

                    gl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height );
                    gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, target.renderbuffer );

                    // clean up

                    gl.bindTexture( gl.TEXTURE_2D, null );
                    gl.bindRenderbuffer( gl.RENDERBUFFER, null );
                    gl.bindFramebuffer( gl.FRAMEBUFFER, null);

                    return target;

                }

                function createRenderTargets() {

                    frontTarget = createTarget( parameters.screenWidth, parameters.screenHeight );
                    backTarget = createTarget( parameters.screenWidth, parameters.screenHeight );

                }

                //

                var dummyFunction = function() {};


                //
                
                function htmlEncode(str){

                    return String(str)
                        .replace(/&/g, '&amp;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');

                }

                //

                function createShader( src, type ) {
                
                    var shader = gl.createShader( type );
                    var line, lineNum, lineError, index = 0, indexEnd;

                    while (errorLines.length > 0) {
                        line = errorLines.pop();
                        code.setLineClass(line, null);
                        code.clearMarker(line);
                    }

                    gl.shaderSource( shader, src );
                    gl.compileShader( shader );

                    compileButton.title = '';

                    if ( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {

                        var error = gl.getShaderInfoLog( shader );
                        
                        // Remove trailing linefeed, for FireFox's benefit.
                        while ((error.length > 1) && (error.charCodeAt(error.length - 1) < 32)) {
                            error = error.substring(0, error.length - 1);
                        }

                        compileButton.title = error;
                        console.error( error );

                        compileButton.style.color = '#ff0000';
                        compileButton.textContent = 'compiled with errors';

                        set_save_button('hidden');

                        while (index >= 0) {
                            index = error.indexOf("ERROR: 0:", index);
                            if (index < 0) { break; }
                            index += 9;
                            indexEnd = error.indexOf(':', index);
                            if (indexEnd > index) {
                                lineNum = parseInt(error.substring(index, indexEnd));
                                if ((!isNaN(lineNum)) && (lineNum > 0)) {
                                    index = indexEnd + 1;
                                    indexEnd = error.indexOf("ERROR: 0:", index);
                                    lineError = htmlEncode((indexEnd > index) ? error.substring(index, indexEnd) : error.substring(index));
                                    line = code.setMarker(lineNum - 1, '<abbr title="' + lineError + '">' + lineNum + '</abbr>', "errorMarker");
                                    code.setLineClass(line, "errorLine");
                                    errorLines.push(line);
                                }
                            }
                        }

                        return null;

                    }

                    return shader;

                }

                //

                function onWindowResize( event ) {

                    var isMaxWidth = ((resizer.currentWidth === resizer.maxWidth) || (resizer.currentWidth === resizer.minWidth)),
                        isMaxHeight = ((resizer.currentHeight === resizer.maxHeight) || (resizer.currentHeight === resizer.minHeight));
            
                    toolbar.style.width = window.innerWidth - 47 + 'px';

                    resizer.isResizing = false;
                    resizer.maxWidth = window.innerWidth - 75;
                    resizer.maxHeight = window.innerHeight - 125;
                    if (isMaxWidth || (resizer.currentWidth > resizer.maxWidth)) {
                        resizer.currentWidth = resizer.maxWidth;
                    }
                    if (isMaxHeight || (resizer.currentHeight > resizer.maxHeight)) {
                        resizer.currentHeight = resizer.maxHeight;
                    }
                    if (resizer.currentWidth < resizer.minWidth) { resizer.currentWidth = resizer.minWidth; }
                    if (resizer.currentHeight < resizer.minHeight) { resizer.currentHeight = resizer.minHeight; }

                    code.getWrapperElement().style.top = '75px';
                    code.getWrapperElement().style.left = '25px';
                    code.getWrapperElement().style.width = resizer.currentWidth + 'px';
                    code.getWrapperElement().style.height = resizer.currentHeight + 'px';

                    canvas.width = window.innerWidth / quality;
                    canvas.height = window.innerHeight / quality;

                    canvas.style.width = window.innerWidth + 'px';
                    canvas.style.height = window.innerHeight + 'px';

                    parameters.screenWidth = canvas.width;
                    parameters.screenHeight = canvas.height;

                    computeSurfaceCorners();

                    if (gl) {
                    
                        gl.viewport( 0, 0, canvas.width, canvas.height );

                        createRenderTargets();
                        
                    }
                }

                //

                function animate() {

                    requestAnimationFrame( animate );
                    render();

                }

                function render() {

                    if ( !currentProgram ) return;

                    parameters.time = Date.now() - parameters.startTime;

                    // Set uniforms for custom shader

                    gl.useProgram( currentProgram );

                    gl.uniform1f( currentProgram.uniformsCache[ 'time' ], parameters.time / 1000 );
                    gl.uniform2f( currentProgram.uniformsCache[ 'mouse' ], parameters.mouseX, parameters.mouseY );
                    gl.uniform2f( currentProgram.uniformsCache[ 'resolution' ], parameters.screenWidth, parameters.screenHeight );
                    gl.uniform1i( currentProgram.uniformsCache[ 'backbuffer' ], 0 );
                    gl.uniform2f( currentProgram.uniformsCache[ 'surfaceSize' ], surface.width, surface.height );

                    gl.bindBuffer( gl.ARRAY_BUFFER, surface.buffer );
                    gl.vertexAttribPointer( surface.positionAttribute, 2, gl.FLOAT, false, 0, 0 );
                    
                    gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
                    gl.vertexAttribPointer( vertexPosition, 2, gl.FLOAT, false, 0, 0 );

                    gl.activeTexture( gl.TEXTURE0 );
                    gl.bindTexture( gl.TEXTURE_2D, backTarget.texture );

                    // Render custom shader to front buffer

                    gl.bindFramebuffer( gl.FRAMEBUFFER, frontTarget.framebuffer );

                    gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
                    gl.drawArrays( gl.TRIANGLES, 0, 6 );

                    // Set uniforms for screen shader

                    gl.useProgram( screenProgram );

                    gl.uniform2f( screenProgram.uniformsCache[ 'resolution' ], parameters.screenWidth, parameters.screenHeight );
                    gl.uniform1i( screenProgram.uniformsCache[ 'texture' ], 1 );

                    gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
                    gl.vertexAttribPointer( screenVertexPosition, 2, gl.FLOAT, false, 0, 0 );
                    
                    gl.activeTexture( gl.TEXTURE1 );
                    gl.bindTexture( gl.TEXTURE_2D, frontTarget.texture );

                    // Render front buffer to screen

                    gl.bindFramebuffer( gl.FRAMEBUFFER, null );

                    gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
                    gl.drawArrays( gl.TRIANGLES, 0, 6 );

                    // Swap buffers

                    var tmp = frontTarget;
                    frontTarget = backTarget;
                    backTarget = tmp;

                }

            </script><canvas width="244" height="454" style="display: block; width: 488px; height: 909px;"></canvas>

        

    </body>
</html>
